#libraries
import logging
from logging.handlers import RotatingFileHandler
import os
from pathlib import Path
import socket
import paramiko
import threading
import time

# Define the path of log files generated by the honeypot
# Note: __file__ won't work in some interactive environments (like Jupyter).
# This assumes you are running this as a .py file.
script_path = Path(__file__).resolve()
project_root_path = script_path.parent.parent.parent
LOG_DIR = project_root_path / 'logs'
os.makedirs(LOG_DIR, exist_ok=True)
LOG_FILE = 'ssh_honeypot_audits.log'
LOG_FILE_1 = 'ssh_honeypot_cmd_audits.log'
log_path = os.path.join(LOG_DIR, LOG_FILE)
log_path_1 = os.path.join(LOG_DIR, LOG_FILE_1)

#constants
logging_format = logging.Formatter('%(message)s')
SSH_BANNER = "SSH-2.0-MYSSHSERVER_1.0"

# host_key generation: Ensure 'server.key' file exists or is generated.
# If you don't have a key file, you can generate one like this:
# from cryptography.hazmat.primitives import rsa
# from cryptography.hazmat.primitives import serialization
# private_key = rsa.generate_private_key(public_exponent=65537, key_size=2048)
# with open("server.key", "wb") as f:
#     f.write(private_key.private_bytes(
#         encoding=serialization.Encoding.PEM,
#         format=serialization.PrivateFormat.TraditionalOpenSSL,
#         encryption_algorithm=serialization.NoEncryption()
#     ))
host_key = paramiko.RSAKey(filename='server.key')

#loggers and logging files
funnel_logger = logging.getLogger('Funnellogger')
funnel_logger.setLevel(logging.INFO)
funnel_handler = RotatingFileHandler(log_path, maxBytes=2000, backupCount=5)
funnel_handler.setFormatter(logging_format)
funnel_logger.addHandler(funnel_handler)

creds_logger = logging.getLogger('Credslogger')
creds_logger.setLevel(logging.INFO)
creds_handler = RotatingFileHandler(log_path_1, maxBytes=2000, backupCount=5)
creds_handler.setFormatter(logging_format)
creds_logger.addHandler(creds_handler)

#emulated shell
def emulated_shell(channel, client_ip):
    """
    Runs a highly polished emulated shell session.
    Features: backspace, command history, fake processes/network, and a more
    believable filesystem to fool beginner to mediocre attackers.
    """
    # --- ANSI Color Codes ---
    BLUE = b'\033[94m'
    RESET = b'\033[0m'

    # --- State for the shell ---
    current_dir = b'/home/user'
    
    # --- Fake File System & Content ---
    filesystem = {
        b'/': [b'bin', b'etc', b'home', b'root', b'var', b'opt'],
        b'/home': [b'user'],
        b'/home/user': [b'.bashrc', b'user_data.txt', b'config.yaml'],
        b'/root': [b'.ssh'],
        b'/root/.ssh': [b'authorized_keys', b'id_rsa'], # Sensitive files
        b'/etc': [b'passwd', b'shadow', b'hosts'],
        b'/var': [b'log'],
        b'/var/log': [b'auth.log', b'syslog']
    }
    
    file_content = {
        b'/etc/passwd': b'root:x:0:0:root:/root:/bin/bash\r\nuser:x:1000:1000:user:/home/user:/bin/bash\r\n',
        b'/home/user/config.yaml': b'api_key: "ak_live_aBcDeFgHiJkLmNoPqRsTuVwXyZ"\r\ndatabase_pass: "S3cuRe_P@ssw0rd_123!"\r\n',
        b'/etc/hosts': b'127.0.0.1\tlocalhost\r\n::1\tlocalhost\r\n'
    }

    # --- Fake History ---
    command_history = [
        b'  1  sudo apt-get update',
        b'  2  ls -la',
        b'  3  vim /etc/hosts',
        b'  4  ping google.com',
        b'  5  history'
    ]

    def get_prompt():
        return b'root@honeypot:' + current_dir + b'# '

    channel.send(get_prompt())
    command = b""

    while True:
        try:
            char = channel.recv(1)
            if not char:
                break
            
            # --- Backspace/Delete Handler ---
            if char in (b'\x08', b'\x7f'): # ASCII for backspace and delete
                if len(command) > 0:
                    command = command[:-1]
                    # Moves cursor back, writes space, moves back again
                    channel.send(b'\b \b')
                continue # Skip the rest of the loop

            # --- Ctrl+C Handler ---
            if char == b'\x03':
                channel.send(b'^C\r\n')
                channel.close()
                print(f"Connection from {client_ip} closed by Ctrl+C.")
                return

            # Echo character back to the user
            channel.send(char)
            command += char

            if char == b'\r':
                channel.send(b'\n')
                full_command = command.strip()
                parts = full_command.split()
                base_command = parts[0] if parts else b''
                response = b''

                # --- Command Emulation Logic ---
                if not base_command:
                    pass
                elif base_command == b'exit':
                    channel.send(b'logout\r\n'); channel.close(); return
                elif base_command == b'pwd':
                    response = current_dir + b'\r\n'
                elif base_command == b'whoami':
                    response = b'root\r\n'
                elif base_command == b'id':
                    response = b'uid=0(root) gid=0(root) groups=0(root)\r\n'
                elif base_command == b'uname' and len(parts) > 1 and parts[1] == b'-a':
                    response = b'Linux honeypot 5.4.0-104-generic #118-Ubuntu SMP x86_64 GNU/Linux\r\n'
                elif base_command == b'history':
                    response = b'\r\n'.join(command_history) + b'\r\n'
                elif base_command == b'ps' and len(parts) > 1 and parts[1] == b'aux':
                    time.sleep(0.1) # Add a slight delay for realism
                    response = (
                        b'USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND\r\n'
                        b'root           1  0.0  0.1  16480  3432 ?        Ss   Oct14   0:02 /sbin/init\r\n'
                        b'root         245  0.0  0.2  78340  4880 ?        Ss   Oct14   0:15 /lib/systemd/systemd-journald\r\n'
                        b'root         512  0.0  0.4  94864  8164 ?        Ss   Oct14   0:01 /usr/sbin/sshd -D\r\n'
                        b'root         620  0.0  0.1  58204  3852 ?        Ss   Oct14   0:05 /usr/sbin/cron -f\r\n'
                    )
                elif base_command == b'netstat' and len(parts) > 1 and parts[1] == b'-tulpn':
                    response = (
                        b'Active Internet connections (only servers)\r\n'
                        b'Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name\r\n'
                        b'tcp        0      0 0.0.0.0:22              0.0.0.0:* LISTEN      512/sshd\r\n'
                        b'tcp        0      0 0.0.0.0:80              0.0.0.0:* LISTEN      - \r\n'
                    )
                elif base_command == b'ls':
                    dir_content = filesystem.get(current_dir, [])
                    output = []
                    for item in dir_content:
                        # Check if item is a directory
                        full_path = current_dir + b'/' + item if current_dir != b'/' else b'/' + item
                        if full_path in filesystem:
                            output.append(BLUE + item + RESET)
                        else:
                            output.append(item)
                    response = b'  '.join(output) + b'\r\n' if output else b'\r\n'
                elif base_command == b'cd':
                    # Simplified cd logic
                    if len(parts) > 1:
                        target = parts[1]
                        if target == b'..':
                            if current_dir != b'/':
                                current_dir = b'/'.join(current_dir.split(b'/')[:-1]) or b'/'
                        else:
                            potential_path = current_dir + b'/' + target if current_dir != b'/' else b'/' + target
                            if potential_path in filesystem:
                                current_dir = potential_path
                            else:
                                response = b'bash: cd: ' + target + b': No such file or directory\r\n'
                    else:
                        current_dir = b'/root' # cd to root's home
                elif base_command == b'cat':
                    if len(parts) > 1:
                        filename = parts[1]
                        # Construct full path
                        filepath = current_dir + b'/' + filename if not filename.startswith(b'/') else filename
                        
                        # --- Security checks for sensitive files ---
                        if filepath == b'/etc/shadow' or filepath == b'/root/.ssh/id_rsa':
                            response = b'cat: ' + filename + b': Permission denied\r\n'
                        elif filepath in file_content:
                            response = file_content[filepath]
                        else:
                            response = b'cat: ' + filename + b': No such file or directory\r\n'
                else:
                    response = b'bash: ' + base_command + b': command not found\r\n'

                if response:
                    channel.send(response)

                channel.send(get_prompt())
                command = b""

        except Exception as e:
            print(f"An error occurred in the emulated shell from {client_ip}: {e}")
            break
# ----------------- FIXES START HERE -----------------

#ssh server + sockets
# CORRECTED: 'class' is no longer indented
class Server(paramiko.ServerInterface):

    def __init__(self, client_ip, input_username=None, input_password=None):
        self.event = threading.Event()
        self.client_ip = client_ip
        self.input_username = input_username
        # CORRECTED: Consistent variable name
        self.input_password = input_password

    def check_channel_request(self, kind: str, chanid: int) -> int:
        if kind == 'session':
            # CORRECTED: Added the missing 'return' statement
            return paramiko.OPEN_SUCCEEDED
        return paramiko.OPEN_FAILED_ADMINISTRATIVELY_PROHIBITED

    # CORRECTED: Method name is now 'get_allowed_auths' and accepts 'username'
    def get_allowed_auths(self, username):
        return "password"

    def check_auth_password(self, username, password):
        # Log the attempt
        creds_logger.info(f'IP: {self.client_ip}, Username: {username}, Password: {password}')

        if self.input_username is not None and self.input_password is not None:
            # CORRECTED: Checks 'username' against 'self.input_username' AND 'password' against 'self.input_password'
            if username == self.input_username and password == self.input_password:
                return paramiko.AUTH_SUCCESSFUL
            else:
                return paramiko.AUTH_FAILED
        else:
            # If no specific credentials are set, accept any.
            return paramiko.AUTH_SUCCESSFUL

    def check_channel_shell_request(self, channel):
        self.event.set()
        return True

    def check_channel_pty_request(self, channel, term, height, width, pixelheight, pixelwidth, modes):
        return True

    def check_channel_exec_request(self, channel, command):
        command = str(command)
        # Log the executed command
        funnel_logger.info(f'IP: {self.client_ip}, Command: {command}')
        return True

#CLIENT HANDLE
def client_handle(client, addr, username, password):
    client_ip = addr[0]
    print(f"Connection from: {client_ip}")

    try:
        transport = paramiko.Transport(client)
        transport.local_version = SSH_BANNER
        server = Server(client_ip=client_ip, input_username=username, input_password=password)
        transport.add_server_key(host_key)
        transport.start_server(server=server)

        channel = transport.accept(20) # Use a timeout
        if channel is None:
            print(f"No channel opened for {client_ip}.")
            transport.close()
            return

        emulated_shell(channel, client_ip=client_ip)

    except paramiko.ssh_exception.SSHException as ssh_error:
        print(f"SSH negotiation failed for {client_ip}: {ssh_error}")
    except Exception as error:
        print(f"!!! Error for {client_ip}: {error}")
    finally:
        try:
            transport.close()
        except Exception:
            pass # Transport might already be closed
        client.close()
        print(f"Connection closed for {client_ip}.")


# provision ssh based honeypot
def ssh_honeypot(address, port, username, password):
    try:
        socks = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        socks.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        socks.bind((address, port))
        socks.listen(100)
        print(f"[*] SSH honeypot listening on {address}:{port}...")

        # CORRECTED: Added a loop to accept multiple connections
        while True:
            client, addr = socks.accept()
            ssh_honeypot_thread = threading.Thread(
                target=client_handle, args=(client, addr, username, password)
            )
            ssh_honeypot_thread.start()

    except Exception as error:
        print(f"!!! Honeypot failed to start: {error}")

# To run the honeypot for a specific user/pass:
ssh_honeypot('127.0.0.1', 9000, 'admin', 'password123')

# To run and accept ANY username/password:
